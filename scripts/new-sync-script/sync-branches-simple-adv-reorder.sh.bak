#!/bin/zsh
# sync-branches-simple.sh

# =====================================================================
# SYNC SCRIPT FLOW OVERVIEW (UI/USER FLOW ORDER)
# =====================================================================

# 1. Drag-and-Drop Support
#    - Detect if script is invoked via drag-and-drop (quoted path).
#    - Re-execute itself with correct path/arguments if needed.

# 2. Pre-Sync Checks & Setup
#    - Ensure script is run inside a git repository.
#    - Parse command-line arguments:
#        --dry-run         Show what would happen without making changes.
#        --auto-commit     Automatically commit unstaged changes before syncing.
#        --debug           Show detailed logs for troubleshooting.
#        --no-verify       Skip pre-commit and pre-push git hooks (skips all git hooks, not just tests; use with caution).
#        --no-lint         Skip linting and formatting checks.
#        --no-tests        Skip running tests before syncing.
#        --config <file>   Use a custom config file for default/toggleable options.
#        --branch <name>   Use a specific branch as source/target for syncing.
#        ...add others as needed for your workflow.
#    - Check for clean working directory (or handle with auto-commit/stash if enabled).
#    - Load config file if present (toggleable default options).

# 3. Interactive Branch Selection
#    - List all local branches, ordered by most recent commit (most recent at the bottom).
#    - Print debug/info messages in the following format by default:
#        [DEBUG] <message>
#        [INFO] <message>
#    - Example:
#        [DEBUG] Running main() in sync-all-files-to-specified-branches.sh
#        [INFO] Running in repository root: /path/to/repo
#        [INFO] Cleaning up temporary files...
#        [INFO] No target branches specified. Please select from the list below:
#    - Number each branch for selection.
#    - Highlight the current branch:
#        * Green asterisk (*) if working directory is clean.
#        * Yellow asterisk (*) if there are unstaged/uncommitted changes.
#    - Prompt user to "Type branch numbers separated by space (e.g. 1 3 5), or '+' to add a new branch. Press 'Enter' when done:"
#    - Option to create a new branch by entering "+".
#    - Validate input and map numbers to branch names.

# 4. Pre-commit Linting/Formatting (toggleable)
#    - Optionally run lint (e.g., npm run lint) and/or formatting checks before auto-commit or sync.
#    - Check for TypeScript errors (e.g., npx tsc --noEmit) and abort or warn if any are found.
#    - Check for ESLint errors (e.g., npx eslint .) and abort or warn if any are found.
#    - Warn if there are lint errors. Ask if the user wants to automatically fix lint errors (e.g., run npm run lint -- --fix or similar).
#    - If user agrees, attempt to fix and re-check; otherwise, abort or continue based on user choice.

# 5. Pre-push Hook Simulation (toggleable)
#    - Optionally run any scripts you have in .husky/pre-push or similar, to catch issues before pushing.

# 6. Auto-commit Flow (if enabled)
#    - Detect if there are any unstaged or uncommitted changes in the working directory.
#    - If changes are present:
#        - Automatically generate a high-quality commit summary using:
#            - Current branch name
#            - List of changed files
#            - Diff summary (git diff --stat)
#            - Test results (Jest, Playwright, etc.) if available
#            - Pre-filled template for Summary, Purpose, Change Details, Diff Summary, Test Results, References
#        - Prompt the user to review, edit, or accept the commit message (optionally open in $EDITOR)
#        - Use the result for the commit
#        - Confirm to the user that the auto-commit was made.
#    - If no changes are present:
#        - Inform the user that the working directory is clean and skip the auto-commit step.

Summary:
Sync feature/login-refactor into main: Unify authentication logic and update tests

Purpose:
- Merge recent authentication improvements from feature/login-refactor into main.
- Ensure all login flows use the new unified logic for better maintainability and test coverage.

Change Details:
- Branch: feature/login-refactor
- Files changed:
  src/auth/session.ts
  src/auth/handlers.ts
  tests/auth.spec.ts
- Resolved merge conflicts in src/auth/session.ts (kept new session validation, removed legacy fallback).
- Updated related unit and e2e tests for new login flow.

Diff Summary:
 src/auth/session.ts      |  45 +++++++++++++++-----
 src/auth/handlers.ts     |  12 +++---
 tests/auth.spec.ts       |  20 ++++++---
 3 files changed, 55 insertions(+), 22 deletions(-)

Test Results:
Jest: All tests passed (112/112), coverage 98%.
Playwright: All e2e login and profile tests passed.
Manual: Verified login/logout and session persistence in local dev.

# 8. Run Jest/Playwright/Other Tests (toggleable)
#    - Run Jest, Playwright, or other tests on the current branch after auto-commit (if enabled).
#    - If tests pass:
#        - Proceed to branch selection and sync/merge.
#    - If tests fail:
#        - Abort the sync, inform the user, and allow them to fix issues before continuing.

# 8. Stash Flow (if enabled)
#    - If you do NOT want to commit your current changes but still want to sync:
#        - Stash any uncommitted changes before syncing (temporarily save and hide them).
#        - Perform the sync/merge operations on the committed state only.
#        - After syncing is complete, restore the stashed changes to your working directory.
#    - This allows you to sync branches without including your current uncommitted work.

# 9. Backup/Restore (sync_tmp_backups/)
#    - Before major syncs/merges, back up the working directory or branch to sync_tmp_backups/.
#    - Only keep the most recent necessary backups, delete old ones to save space.
#    - Allow easy restore if needed.

# 10. Sync/Merge Flow (toggleable parallel)
#    - For each selected target branch (in parallel if enabled):
#        - Checkout target branch.
#        - Merge current branch into target.
#        - Handle merge conflicts interactively (offer to open conflicted files in editor).
#        - Prompt for/edit commit message if needed (show diff summary and allow editing).
#        - Push to remote.
#        - Log/report success or failure.

# 11. Sync/Push Summary Table
#    - After all syncs, print a summary table showing which branches were updated, pushed, or had errors.

# 12. Post-Sync Actions
#    - Return to original branch.
#    - Show post-sync diff summary (e.g., git diff --stat).
#    - Cleanup any temporary state.

# 13. Open GitHub Page After Upload
#    - After a successful push to remote, automatically open the corresponding GitHub page for the branch in the default browser.
#    - Inform the user that the page is being opened.

# 14. Branch Cleanup (Optional)
#    - After syncing, provide an option to delete unneeded branches.
#        - Allow deletion of local branches.
#        - Allow deletion of remote branches (with confirmation).
#    - Confirm branch deletion actions with the user before proceeding.

# 15. Error Handling & Logging
#    - Log all major actions and errors.
#    - Abort on critical errors, continue with others if possible.
#    - Provide clear user feedback at each step.

# 16. Partial Commit/Stash (Optional)
#    - Allow user to perform partial commit (git add -p) or partial stash (git stash -p) as an option before sync/merge.
#    - Useful for syncing only selected changes.

# 17. Pre-flight Remote Status Check
#    - Before merging/pushing, check if the local branch is behind/diverged from remote and prompt the user to pull/rebase if needed.

# 18. CI/CD Status Awareness (Optional)
#    - After push (or before merge), check CI/CD status for the branch and warn if the last build failed. Make this toggleable.

# 19. User Confirmation for Destructive Actions
#    - Before deleting branches (local or remote), always prompt for confirmation and clearly explain the consequences.

# 20. Clear Success/Failure Feedback
#    - After each major step (commit, test, merge, push), print a clear success or failure message, and if failed, suggest next actions.

# 21. Help/Docs Accessibility
#    - Make sure the help/docs output is accessible from anywhere in the flow (e.g., allow --help at any prompt).

# 22. Restore/Abort Safety
#    - If a step fails (e.g., merge conflict, test failure), offer to restore from backup or stash, and clearly explain how to recover.

# 23. Partial Commit/Stash UX
#    - If partial commit/stash is chosen, make it clear in the UI what is being included/excluded, and confirm before proceeding.

# 24. Config/Defaults Feedback
#    - If a config file is loaded, print which options are being overridden for transparency.

# 25. Logging/Debug Output
#    - If debug is enabled, print all relevant variables and decisions at each step for troubleshooting.

# 26. Multi-branch Sync Parallelism
#    - If syncing to multiple branches in parallel, print progress and results for each branch separately, and summarize at the end.

# 27. Editor Integration
#    - If $EDITOR is not set, default to vi or prompt the user to set it.

# 28. Accessibility
#    - Use clear color coding and avoid color-only cues for important warnings (for accessibility).

# 29. Exit Codes
#    - Use meaningful exit codes for automation (e.g., 0=success, 1=abort, 2=conflict, etc.).

# 30. Optional: Undo Last Action
#    - After a destructive action (delete, force push), offer a quick “undo” if possible (e.g., git reflog for branch recovery).

# Note: Each major step should check the DRY_RUN flag and print what would happen instead of making changes if enabled.
# =====================================================================
# ADVANCED FEATURES
# =====================================================================
# - All features above should be implemented as toggleable where noted.
# - Backup files should be managed in sync_tmp_backups/ as described.
# - Config file support for default/toggleable options.
# - Debug mode for troubleshooting.
# - Dry run enhancements for previewing all actions.
# =====================================================================
# (Implementation starts below)

# =====================================================================
# UTILITY: Colorized Output
# =====================================================================
color_info="\033[1;34m"   # Blue
color_warn="\033[1;33m"   # Yellow
color_error="\033[1;31m"  # Red
color_success="\033[1;32m" # Green
color_reset="\033[0m"

info()    { echo -e "${color_info}[INFO] $*${color_reset}"; }
warn()    { echo -e "${color_warn}[WARN] $*${color_reset}"; }
error()   { echo -e "${color_error}[ERROR] $*${color_reset}"; }
success() { echo -e "${color_success}[SUCCESS] $*${color_reset}"; }
debug()   { [[ "$DEBUG" == "1" ]] && echo -e "[DEBUG] $*"; }

# =====================================================================
# UTILITY: Print Help/Docs
# =====================================================================
print_help() {
  cat <<EOF
Usage: $0 [options]

Options:
  --dry-run         Preview all actions without making changes
  --auto-commit     Auto-commit unstaged changes before syncing
  --debug           Enable debug output
  --no-verify       Skip all git hooks
  --no-lint         Skip linting/formatting
  --no-tests        Skip running tests
  --config <file>   Use custom config file
  --branch <name>   Specify branch for sync
  --rebase          Use rebase instead of merge
  --list-backups    List available backups
  --restore-backup  Restore a backup interactively
  --delete-backup   Delete a backup interactively
  --help, --docs    Show this help message
EOF
}

# =====================================================================
# UTILITY: Modular Hooks
# =====================================================================
run_hook() {
  local hook_name="$1"
  local config_file="$CONFIG_FILE"
  [[ -z "$config_file" ]] && config_file=".sync-branches.conf"
  if [[ -f "$config_file" ]]; then
    local hook_cmd=$(grep "^$hook_name=" "$config_file" | cut -d'=' -f2-)
    if [[ -n "$hook_cmd" ]]; then
      info "Running $hook_name hook: $hook_cmd"
      eval "$hook_cmd"
    fi
  fi
}

# =====================================================================
# UTILITY: Branch Protection Awareness
# =====================================================================
is_protected_branch() {
  local branch="$1"
  [[ "$branch" =~ ^(main|master|production|release)$ ]] && return 0 || return 1
}

# =====================================================================
# UTILITY: Interactive Conflict Resolution
# =====================================================================
resolve_conflicts() {
  if command -v fzf >/dev/null 2>&1; then
    info "Launching fzf for conflict resolution..."
    git status --porcelain | grep '^UU' | cut -c4- | fzf --multi --prompt="Select files to resolve: "
  elif command -v gitui >/dev/null 2>&1; then
    info "Launching gitui for conflict resolution..."
    gitui
  else
    warn "No TUI found. Opening conflicted files in \"$EDITOR\"."
    for file in $(git status --porcelain | grep '^UU' | cut -c4-); do
      "$EDITOR" "$file"
    done
  fi
}

# =====================================================================
# UTILITY: Pre-flight Remote Sync Check
# =====================================================================
check_remote_divergence() {
  local branch="$1"
  git fetch origin "$branch"
  local local_hash=$(git rev-parse "$branch")
  local remote_hash=$(git rev-parse "origin/$branch")
  if [[ "$local_hash" != "$remote_hash" ]]; then
    warn "Remote branch '$branch' has diverged. Please pull/rebase before syncing."
    return 1
  fi
  return 0
}

# =====================================================================
# UTILITY: CI/CD Status Check (stub)
# =====================================================================
check_cicd_status() {
  info "(Stub) Checking CI/CD status for branch $1..."
  # Implement GitHub Actions or CI polling here
}

# =====================================================================
# UTILITY: Partial Stash/Commit
# =====================================================================
partial_commit() {
  info "Starting partial commit (git add -p)..."
  git add -p
  git commit
}
partial_stash() {
  info "Starting partial stash (git stash -p)..."
  git stash -p
}

# =====================================================================
# UTILITY: Enhanced Backup Management
# =====================================================================
list_backups() {
  info "Available backups:"
  ls -1 sync_tmp_backups/
}
restore_backup() {
  list_backups
  read "?Enter backup name to restore: " backup
  if [[ -d sync_tmp_backups/$backup ]]; then
    info "Restoring backup $backup..."
    cp -r sync_tmp_backups/$backup/* .
  else
    error "Backup not found."
  fi
}
delete_backup() {
  list_backups
  read "?Enter backup name to delete: " backup
  if [[ -d sync_tmp_backups/$backup ]]; then
    info "Deleting backup $backup..."
    rm -rf sync_tmp_backups/$backup
  else
    error "Backup not found."
  fi
}

# =====================================================================
# UTILITY: Auto-generate Commit Message and Interactive Review
# =====================================================================
generate_commit_message() {
  local branch_name
  branch_name=$(git rev-parse --abbrev-ref HEAD)
  local changed_files
  changed_files=$(git diff --cached --name-only)
  local diff_stat
  diff_stat=$(git diff --cached --stat)
  local type_of_change
  # Infer type from branch name (feature/, fix/, refactor/, chore/, etc.)
  if [[ "$branch_name" =~ ^feature ]]; then
    type_of_change="feat"
  elif [[ "$branch_name" =~ ^fix ]]; then
    type_of_change="fix"
  elif [[ "$branch_name" =~ ^refactor ]]; then
    type_of_change="refactor"
  elif [[ "$branch_name" =~ ^chore ]]; then
    type_of_change="chore"
  else
    type_of_change="update"
  fi

  # Suggest a concise, imperative title (72 chars max for GitHub)
  local default_title
  default_title="${type_of_change}: $(echo $changed_files | head -n1 | cut -c1-50) [${branch_name}]"
  default_title="${default_title:0:72}"

  # Prompt for title, pre-filled
  echo -n "Enter commit title (max 72 chars): [$default_title] "
  read commit_title
  [[ -z "$commit_title" ]] && commit_title="$default_title"
  if (( ${#commit_title} > 72 )); then
    warn "Title exceeds 72 characters. It will be truncated."
    commit_title="${commit_title:0:72}"
  fi

  # Prompt for body
  echo "Enter commit body (why/how, references, etc.). Press Ctrl+D when done:"
  commit_body=$(cat)
  if (( ${#commit_body} > 65536 )); then
    warn "Body exceeds 65536 characters. It will be truncated."
    commit_body="${commit_body:0:65536}"
  fi

  # Add diff summary and references if available
  local references
  references=$(git log --oneline --decorate | grep -Eo '#[0-9]+' | head -1)
  local commit_message
  commit_message="$commit_title\n\n$commit_body\n\nDiff Summary:\n$diff_stat\n"
  [[ -n "$references" ]] && commit_message+="\nReferences: $references\n"

  # Preview and confirm
  echo "\n----- Commit Preview (truncated if too long) -----"
  if (( ${#commit_message} > 65536 )); then
    echo "$(echo "$commit_message" | head -c 65536)"
    warn "Full commit message exceeds GitHub's 65536 character limit. Preview truncated."
  else
    echo "$commit_message"
  fi
  echo "-------------------------"
  echo -n "Proceed with this commit? (y/n/e=edit): "
  read confirm
  if [[ "$confirm" == "e" ]]; then
    # Open in $EDITOR for review
    tmpfile=$(mktemp)
    echo "$commit_message" > "$tmpfile"
    ${EDITOR:-vi} "$tmpfile"
    commit_message=$(cat "$tmpfile")
    rm "$tmpfile"
    # Enforce limits again after editing
    if (( $(echo "$commit_message" | head -n1 | wc -c) > 73 )); then
      warn "Edited title exceeds 72 characters. It will be truncated."
      commit_title="$(echo "$commit_message" | head -n1 | cut -c1-72)"
      commit_message="$commit_title\n$(echo "$commit_message" | tail -n +2)"
    fi
    if (( ${#commit_message} > 65536 )); then
      warn "Edited commit message exceeds 65536 characters. It will be truncated."
      commit_message="$(echo "$commit_message" | head -c 65536)"
    fi
    echo "\n----- Edited Commit Preview (truncated if too long) -----"
    echo "$commit_message"
    echo "-------------------------"
    echo -n "Proceed with this commit? (y/n): "
    read confirm
  fi
  if [[ "$confirm" == "y" ]]; then
    # Split title/body for git commit
    local title body
    title="$(echo "$commit_message" | head -n1)"
    body="$(echo "$commit_message" | tail -n +2)"
    git commit -m "$title" -m "$body" --edit
    success "Commit created."
  else
    warn "Commit aborted."
    return 1
  fi
}

# =====================================================================
# MODULE IMPORTS (source utility modules)
# =====================================================================
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]:-${(%):-%N}}")" && pwd)"
source "$SCRIPT_DIR/lib/colors.sh"
source "$SCRIPT_DIR/lib/hooks.sh"
source "$SCRIPT_DIR/lib/branch-protection.sh"
source "$SCRIPT_DIR/lib/conflict-resolution.sh"
source "$SCRIPT_DIR/lib/remote-sync.sh"
source "$SCRIPT_DIR/lib/cicd.sh"
source "$SCRIPT_DIR/lib/partial-commit.sh"
source "$SCRIPT_DIR/lib/backup.sh"
source "$SCRIPT_DIR/lib/cli-parse.sh"

# Parse CLI arguments (robust)
parse_cli_args "$@"

# =====================================================================
# CLI ARGUMENT PARSING (add new flags)
# =====================================================================
DRY_RUN=0; DEBUG=1; REBASE=0; LIST_BACKUPS=0; RESTORE_BACKUP=0; DELETE_BACKUP=0; CONFIG_FILE=""
for arg in "$@"; do
  case $arg in
    --dry-run) DRY_RUN=1 ;;
    --auto-commit) AUTO_COMMIT=1 ;;
    --debug) DEBUG=1 ;;
    --no-verify) NO_VERIFY=1 ;;
    --no-lint) NO_LINT=1 ;;
    --no-tests) NO_TESTS=1 ;;
    --config) CONFIG_FILE="$2"; shift ;;
    --branch) BRANCH="$2"; shift ;;
    --rebase) REBASE=1 ;;
    --list-backups) LIST_BACKUPS=1 ;;
    --restore-backup) RESTORE_BACKUP=1 ;;
    --delete-backup) DELETE_BACKUP=1 ;;
    --help|--docs) print_help; exit 0 ;;
  esac
  shift
done

# =====================================================================
# MAIN ENTRY (modular, testable)
# =====================================================================
main() {
  if [[ $LIST_BACKUPS -eq 1 ]]; then list_backups; exit 0; fi
  if [[ $RESTORE_BACKUP -eq 1 ]]; then restore_backup; exit 0; fi
  if [[ $DELETE_BACKUP -eq 1 ]]; then delete_backup; exit 0; fi
  # ...existing code continues...
}

main "$@"
