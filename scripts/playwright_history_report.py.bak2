#!/usr/bin/env python3
import sys
from playwright_report import parse, db, report_txt, report_html
import argparse
from pathlib import Path
import json
import datetime

OUTPUT_FILE = Path("scripts/reports/playwright-output.txt")


def generate_summary_table(db_obj):
    summary = {
        "Total Tests": len(db_obj.get("tests", [])),
        "Passed": sum(1 for t in db_obj.get("tests", []) if t.get("status") == "passed"),
        "Failed": sum(1 for t in db_obj.get("tests", []) if t.get("status") == "failed"),
        "Flaky": sum(1 for t in db_obj.get("tests", []) if t.get("status") == "flaky"),
        "Skipped": sum(1 for t in db_obj.get("tests", []) if t.get("status") == "skipped"),
    }
    return summary


def write_markdown_report(db_obj, run_stats, include_sections):
    # Recompute summary from latest test history (use last status in history if available)
    tests = db_obj.get("tests", [])
    summary = {
        "Total Tests": len(tests),
        "Passed": 0,
        "Failed": 0,
        "Flaky": 0,
        "Skipped": 0,
    }
    for t in tests:
        last_status = t.get("status")
        # If history exists, use last entry
        if t.get("history"):
            last_hist = t["history"][-1]
            if last_hist in ("\u2713", "passed", "‚úÖ"): last_status = "passed"
            elif last_hist in ("\u2718", "failed", "‚ùå"): last_status = "failed"
            elif last_hist in ("flaky", "‚ö†Ô∏è"): last_status = "flaky"
            elif last_hist in ("skipped", "‚ûñ"): last_status = "skipped"
        if last_status == "passed": summary["Passed"] += 1
        elif last_status == "failed": summary["Failed"] += 1
        elif last_status == "flaky": summary["Flaky"] += 1
        elif last_status == "skipped": summary["Skipped"] += 1
    total = summary["Total Tests"]
    passed = summary["Passed"]
    failed = summary["Failed"]
    flaky = summary["Flaky"]
    skipped = summary["Skipped"]
    pass_rate = (passed / total) * 100 if total > 0 else 0
    fail_rate = (failed / total) * 100 if total > 0 else 0
    coverage = run_stats.get("coverage", {})
    badge_url = lambda label, value, color: f"https://img.shields.io/badge/{label}-{value}-{color}.svg"
    flaky_badge = badge_url('Flaky', flaky, 'yellow')
    regression_badge = badge_url('Regression', failed, 'orange')
    prev_coverage = run_stats.get("prev_coverage", {})
    coverage_delta = None
    if coverage and prev_coverage:
        try:
            coverage_delta = coverage.get('lines', 0) - prev_coverage.get('lines', 0)
        except Exception:
            coverage_delta = None
    trends = run_stats.get("historical_trends", [])
    with open(report_txt.REPORT_TXT_FILE, "w") as f:
        f.write("# Playwright Test Report\n\n")
        # Badges
        f.write(f"![Pass Rate]({badge_url('Pass_Rate', f'{pass_rate:.1f}%', 'brightgreen')}) ")
        f.write(f"![Fail Rate]({badge_url('Fail_Rate', f'{fail_rate:.1f}%', 'red')}) ")
        f.write(f"![Flaky]({flaky_badge}) ")
        f.write(f"![Regression]({regression_badge}) ")
        if coverage:
            f.write(f"![Coverage]({badge_url('Coverage', f'{coverage.get('lines', 0)}%', 'blue')}) ")
            if coverage_delta is not None:
                sign = '+' if coverage_delta >= 0 else ''
                f.write(f"![Coverage Delta](https://img.shields.io/badge/Coverage{sign}{coverage_delta}-{'brightgreen' if coverage_delta >= 0 else 'red'}.svg) ")
        f.write("\n\n")
        # Summary heatmap/sparkline for pass/fail over time
        if trends:
            heatmap = ''.join(['üü©' if t['passed'] else 'üü•' for t in trends])
            f.write(f"**Summary Heatmap:** {heatmap}\n\n")
        if "summary" in include_sections:
            f.write("## Summary\n\n")
            for key, value in summary.items():
                f.write(f"- **{key}:** {value}\n")
        if "table-of-contents" in include_sections:
            f.write("\n## Table of Contents\n\n")
            f.write("- [Summary](#summary)\n")
            f.write("- [Tests Needing Attention](#tests-needing-attention)\n")
            f.write("- [Flaky Tests](#flaky-tests)\n")
            f.write("- [Test Results](#test-results)\n")
            f.write("- [Coverage](#coverage)\n")
            f.write("- [Trend Graph](#trend-graph)\n")
            f.write("- [Skipped Tests](#skipped-tests)\n")
            f.write("- [Deleted Tests](#deleted-tests)\n")
        # Highlight problematic tests
        if True:
            f.write("\n## Tests Needing Attention\n\n")
            for test in db_obj.get("tests", []):
                if test.get("status") in ("failed", "flaky") or (test.get("history", []) and test.get("history", [])[-1] in ("\u2718", "failed", "‚ùå", "flaky", "‚ö†Ô∏è")):
                    name = test.get("title") or test.get("name")
                    f.write(f"- **{name}** ({test.get('file')}) - Last: {test.get('status')} at {test.get('last_time', '')}\n")
        # Flaky tests section
        if True:
            f.write("\n## Flaky Tests\n\n")
            for test in db_obj.get("tests", []):
                if test.get("status") == "flaky" or any(s in ("flaky", "‚ö†Ô∏è") for s in test.get("history", [])):
                    name = test.get("title") or test.get("name")
                    f.write(f"- **{name}** ({test.get('file')}) - Last: {test.get('status')} at {test.get('last_time', '')}\n")
        if "test-results" in include_sections:
            f.write("\n## Test Results\n\n")
            # Group by file
            tests_by_file = {}
            for test in db_obj.get("tests", []):
                file = test.get("file", "unknown")
                if file not in tests_by_file:
                    tests_by_file[file] = []
                tests_by_file[file].append(test)
            # GitHub repo URL (customize as needed)
            for file, tests in tests_by_file.items():
                f.write(f"<details><summary><strong>{file}</strong></summary>\n\n")
                f.write("| Test | Status | Pass | Fail | Flaky | Skipped | Last Run | Trend | Duration |\n")
                f.write("|------|--------|------|------|-------|---------|----------|-------|----------|\n")
                for test in tests:
                    passes = sum(1 for s in test.get("history", []) if s in ("\u2713", "passed", "‚úÖ"))
                    fails = sum(1 for s in test.get("history", []) if s in ("\u2718", "failed", "‚ùå"))
                    flakies = sum(1 for s in test.get("history", []) if s in ("flaky", "‚ö†Ô∏è"))
                    skips = sum(1 for s in test.get("history", []) if s in ("skipped", "‚ûñ"))
                    last_status = test.get("status")
                    last_time = test.get("last_time", "")
                    name = test.get("title") or test.get("name")
                    # Clickable local VSCode link (preferred)
                    location = test.get("name")
                    file_link = None
                    rerun_cmd = None
                    if ":" in location:
                        parts = location.split(":")
                        if len(parts) >= 3:
                            file_part = parts[0]
                            line_part = parts[1]
                            file_link = f"vscode://file/{file_part}:{line_part}"
                            rerun_cmd = f"npx playwright test {file_part} --line {line_part}"
                    if file_link:
                        name_md = f"[{name}]({file_link})"
                    else:
                        name_md = name
                    # Add rerun command if available
                    if rerun_cmd:
                        name_md += f"<br><sub><code>{rerun_cmd}</code></sub>"
                    # Emoji for status
                    if last_status in ("\u2713", "passed", "‚úÖ"): emoji = "‚úÖ"
                    elif last_status in ("\u2718", "failed", "‚ùå"): emoji = "‚ùå"
                    elif last_status in ("flaky", "‚ö†Ô∏è"): emoji = "‚ö†Ô∏è"
                    elif last_status in ("skipped", "‚ûñ"): emoji = "‚ûñ"
                    else: emoji = "‚ö†Ô∏è"
                    trend = "".join(["üü©" if s in ("\u2713", "passed", "‚úÖ") else "üü•" if s in ("\u2718", "failed", "‚ùå") else "üü®" if s in ("flaky", "‚ö†Ô∏è") else "‚ûñ" for s in test.get("history", [])[-5:]])
                    avg_duration = test.get("avg_duration")
                    last_duration = test.get("last_duration")
                    duration_str = f"{last_duration or '-'} / {avg_duration or '-'}"
                    details_id = name_md.replace(' ', '-').replace('/', '-').replace(':', '-')
                    f.write(f"| <details><summary>{name_md}</summary>\n\nFull history: {test.get('history', [])}\n\n</details> | {emoji} | {passes} | {fails} | {flakies} | {skips} | {last_time} | {trend} | {duration_str} |\n")
                f.write("\n</details>\n\n")
        if "coverage" in include_sections:
            f.write("\n## Coverage\n\n")
            coverage = run_stats.get("coverage", {})
            for key, value in coverage.items():
                f.write(f"- **{key}:** {value}%\n")
        if "trend-graph" in include_sections:
            f.write("\n## Trend Graph\n\n")
            # Use last 20 test results for a more informative trend
            last_statuses = []
            for t in db_obj.get("tests", []):
                if t.get("history"):
                    last_statuses.extend(t["history"][-5:])
            trend = "üìà Trend: " + "".join([
                "üü©" if s in ("\u2713", "passed", "‚úÖ") else "üü•" if s in ("\u2718", "failed", "‚ùå") else "üü®" if s in ("flaky", "‚ö†Ô∏è") else "‚ûñ" for s in last_statuses[-20:]
            ])
            f.write(f"{trend}\n")
            # Compute pass/fail rates from last statuses
            pass_count = sum(1 for s in last_statuses if s in ("\u2713", "passed", "‚úÖ"))
            fail_count = sum(1 for s in last_statuses if s in ("\u2718", "failed", "‚ùå"))
            flaky_count = sum(1 for s in last_statuses if s in ("flaky", "‚ö†Ô∏è"))
            skip_count = sum(1 for s in last_statuses if s in ("skipped", "‚ûñ"))
            total_count = len(last_statuses)
            pass_rate = (pass_count / total_count) * 100 if total_count > 0 else 0
            fail_rate = (fail_count / total_count) * 100 if total_count > 0 else 0
            f.write(f"- **Pass Rate:** {pass_rate:.2f}%\n")
            f.write(f"- **Fail Rate:** {fail_rate:.2f}%\n")
            f.write(f"- **Flaky:** {flaky_count}\n")
            f.write(f"- **Skipped:** {skip_count}\n")
            # Historical trends section
            if trends:
                f.write("\n### Historical Trends\n\n")
                f.write("| Run | Pass | Fail | Flaky | Skipped |\n")
                f.write("|-----|------|------|-------|---------|\n")
                for i, t in enumerate(trends):
                    f.write(f"| {i+1} | {t.get('passed',0)} | {t.get('failed',0)} | {t.get('flaky',0)} | {t.get('skipped',0)} |\n")
        if "skipped-tests" in include_sections:
            f.write("\n## Skipped Tests\n\n")
            skipped_tests = [t for t in db_obj.get("tests", []) if t.get("status") == "skipped"]
            for test in skipped_tests:
                f.write(f"- **{test.get('name')}** (last: {test.get('last_time', '')})\n")
        if "deleted-tests" in include_sections:
            f.write("\n## Deleted Tests\n\n")
            deleted_tests = [t for t in db_obj.get("tests", []) if t.get("status") == "deleted"]
            for test in deleted_tests:
                f.write(f"- **{test.get('name')}** (last: {test.get('last_time', '')})\n")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--worker-mode', choices=['single', 'multi'], default=None, help='Worker mode: single or multi')
    parser.add_argument('--include-sections', nargs='+', default=['summary', 'test-results', 'coverage', 'trend-graph', 'skipped-tests', 'deleted-tests'], help='Sections to include in the report')
    args = parser.parse_args()

    # Load from history.json instead of parsing output.txt
    history_json_path = Path("scripts/reports/playwright-history.json")
    if not history_json_path.exists():
        print(f"[ERROR] {history_json_path} not found. Cannot generate report.")
        sys.exit(1)
    with open(history_json_path) as f:
        history_data = json.load(f)

    # Flatten test results from history.json
    tests = []
    for key, value in history_data.items():
        if key == "migrated":
            continue
        test_entry = {
            "name": value.get("location", key),
            "status": value.get("last_status"),
            "file": value.get("file"),
            "history": value.get("history", []),
            "last_time": value.get("last_time"),
        }
        tests.append(test_entry)

    db_obj = {"tests": tests}
    # Optionally, you can load coverage from history or keep as static
    run_stats = {"coverage": {"statements": 85, "branches": 80, "lines": 90, "functions": 88}}
    write_markdown_report(db_obj, run_stats, include_sections=args.include_sections)
    print(f"[INFO] Markdown summary written to {report_txt.REPORT_TXT_FILE}")
    report_html.generate_html_report(db_obj)
    print(f"[INFO] HTML summary written to scripts/reports/playwright-history.html")


if __name__ == "__main__":
    main()
    # Open the HTML report automatically (macOS only)
    html_report_path = Path("scripts/reports/playwright-history.html")
    import platform
    import subprocess
    if html_report_path.exists():
        system = platform.system()
        if system == "Darwin":
            subprocess.run(["open", str(html_report_path)])
        elif system == "Windows":
            subprocess.run(["start", str(html_report_path)], shell=True)
        elif system == "Linux":
            subprocess.run(["xdg-open", str(html_report_path)])
